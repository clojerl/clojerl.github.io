{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Clojure for the Erlang VM Erlang is a great language for building safe, reliable and scalable systems. It provides immutable, persistent data structures out of the box and its concurrency semantics are unequalled by any other language. Clojure is a Lisp and as such comes with all the goodies Lisps provide. Apart from these Clojure also introduces powerful abstractions such as protocols, multi-methods and seqs, to name a few. Clojure was originally built to simplify the development of concurrent programs in the JVM. Some of its concurrency abstractions could be adapted to Erlang, but this is not the main goal of this project. Its main goal is to combine the power of the Erlang VM with the expressiveness of Clojure to provide an interesting, useful result that might make the lives of many programmers simpler and make the world a happier place.","title":"Clojerl"},{"location":"#clojure-for-the-erlang-vm","text":"Erlang is a great language for building safe, reliable and scalable systems. It provides immutable, persistent data structures out of the box and its concurrency semantics are unequalled by any other language. Clojure is a Lisp and as such comes with all the goodies Lisps provide. Apart from these Clojure also introduces powerful abstractions such as protocols, multi-methods and seqs, to name a few. Clojure was originally built to simplify the development of concurrent programs in the JVM. Some of its concurrency abstractions could be adapted to Erlang, but this is not the main goal of this project. Its main goal is to combine the power of the Erlang VM with the expressiveness of Clojure to provide an interesting, useful result that might make the lives of many programmers simpler and make the world a happier place.","title":"Clojure for the Erlang VM"},{"location":"available-features/","text":"Available Features We provide here a list of the features that are already implemented and available, the ones that are still missing and those that can't or won't be supported. For a detailed list on the differences between Clojerl and Clojure please check here . Implemented Special Forms Clojure: def , do , fn* , if , quote , let* , letfn* , loop* , recur , case* , throw , try , var , import* , new , deftype* , defprotocol* , extend-type* , . , reify* Erlang: receive* , erl-binary* , erl-list* , erl-alias* , erl-on-load* Multi-method Reader Namespaced maps Data Structures Clojure ChunkedCons Cons LazySeq List Map Range Set SortedSet SortedMap Vector Vector.ChunkedSeq Erlang Map List Tuple Concurrency Atom (experimental) Agent (experimental) Delay (experimental) Future Promise CountDownLatch (experimental) Clojure Libraries clojure.core clojure.core.server clojure.data clojure.edn clojure.erlang.io clojure.instant clojure.repl clojure.main clojure.pprint clojure.set clojure.stacktrace clojure.string clojure.template clojure.test clojure.uuid clojure.walk clojure.xml clojure.zip Transducers Not Implemented Multi-method Hierarchies Concurrency Ref (no plans for implementation) Clojure Libraries clojure.erlang.erldocs clojure.erlang.shell clojure.core.reducers clojure.spec Unsupported Special Forms proxy Concurrency Volatile Data Structures Transient collections StructMaps (see why here ) Math unchecked","title":"Available Features"},{"location":"available-features/#available-features","text":"We provide here a list of the features that are already implemented and available, the ones that are still missing and those that can't or won't be supported. For a detailed list on the differences between Clojerl and Clojure please check here .","title":"Available Features"},{"location":"available-features/#implemented","text":"Special Forms Clojure: def , do , fn* , if , quote , let* , letfn* , loop* , recur , case* , throw , try , var , import* , new , deftype* , defprotocol* , extend-type* , . , reify* Erlang: receive* , erl-binary* , erl-list* , erl-alias* , erl-on-load* Multi-method Reader Namespaced maps Data Structures Clojure ChunkedCons Cons LazySeq List Map Range Set SortedSet SortedMap Vector Vector.ChunkedSeq Erlang Map List Tuple Concurrency Atom (experimental) Agent (experimental) Delay (experimental) Future Promise CountDownLatch (experimental) Clojure Libraries clojure.core clojure.core.server clojure.data clojure.edn clojure.erlang.io clojure.instant clojure.repl clojure.main clojure.pprint clojure.set clojure.stacktrace clojure.string clojure.template clojure.test clojure.uuid clojure.walk clojure.xml clojure.zip Transducers","title":"Implemented"},{"location":"available-features/#not-implemented","text":"Multi-method Hierarchies Concurrency Ref (no plans for implementation) Clojure Libraries clojure.erlang.erldocs clojure.erlang.shell clojure.core.reducers clojure.spec","title":"Not Implemented"},{"location":"available-features/#unsupported","text":"Special Forms proxy Concurrency Volatile Data Structures Transient collections StructMaps (see why here ) Math unchecked","title":"Unsupported"},{"location":"differences-with-clojure/","text":"(This document was built using the one from ClojureScript as a guide). Rationale Erlang is a great language for building safe, reliable and scalable systems. It provides immutable, persistent data structures out of the box and its concurrency semantics are unequalled by any other language. Clojure is a Lisp and as such comes with all the goodies Lisps provide. Apart from these Clojure also introduces powerful abstractions such as protocols, multimethods and seqs, to name a few. Clojure was built to simplify the development of concurrent programs and some of its concurrency abstractions could be adapted to Erlang. It is fair to say that combining the power of the Erlang VM with the expressiveness of Clojure could provide an interesting, useful result to make the lives of many programmers simpler and make the world a happier place. State and Identity The Erlang VM implements the actor model, which means identity is generally bound to a process which maintains an internal state . This doesn't mean that the Clojure identity model can't be implemented, but since the platform favors the actor model, it will always be more efficient using it than the Clojure model. clojure.spec Not implemented (yet). Dynamic Development There is a REPL available just like Clojure's. Functional Programming Since the Erlang VM already includes native immutable data structures, Clojerl includes most of the same immutable data structures present in Clojure. Some of them are implemented based on other immutable data structures (e.g. sorted sets). Lisp Same as in Clojure. Runtime Polymorphism Protocols and multimethods are available as in Clojure. Everything is implemented in terms of protocols, there are no interfaces. proxy is not supported. Concurrent Programming TBD Hosted on the JVM Hosted on the Erlang VM. Getting Started Getting started . The Reader Numbers All integer numbers are mapped to Erlang's representation, which are arbitrary precision integers. Numbers with a decimal part are mapped to Erlang's representation of floating point numbers. Ratio and BigDecimal are not supported. Characters are represented as single-character strings. nil is currently mapped to the :undefined keyword. This is because :undefined is generally used in Erlang to specify 'nothing/no-value'. true and false are equivalent to :true and :false respectively. Lists, Vectors, Maps and Sets are the same as in Clojure. There is no support yet for the Map namespace syntax . Macro characters Because there is no character type in Erlang, \\ produces a single-character string. The REPL and main See Getting started for instructions on the Clojerl REPL. The bin/clojerl and bin/clje scripts can be used the same as bin/clojure and bin/clj . Evaluation Clojerl has the same evaluation rules as Clojure. Special Forms The following Clojerl special forms are identical to their Clojure cousins: if , do , let , letfn , quote and loop . fn Compile to an Erlang function and therefore can't have any metadata. recur recur is compiled to an actual recursive call that is only allowed in tail position, since the Erlang VM implements tail call optimization. def When the init expression is a fn , def produces one or more Erlang functions, depending on the arities specified in the fn declaration. When not an fn , the init expression ( which is evaluated at compile-time ) must return a constant literal, otherwise it's a compile-time error. throw There is no error type in Erlang, any value can be thrown. try..catch..finally An exception in Erlang consists of three things: the class of the exception ( throw , error or exit ), the exit reason and the stack-trace. There is no specific type for exceptions. The spec for the catch clause is (catch error-type error & body) , where error-type is one of the keywords :throw , :error , :exit or _ . The last one will catch all the error types. var Vars are not reified as in Clojure, they are more similar to what ClojureScript does, which returns compile time information about the var, and during runtime the information available is static (i.e. can't be modified without recompiling). Vars can't have watches or a validator. It's not possible to change the root binding of a Var. monitor-enter , monitor-exit , and locking are not supported. Macros Macros in Clojerl work the same as in Clojure. Other Useful Functions and Macros Regex support is the one provided by the re Erlang module. Data Structures nil 's type is clojerl.Nil . It is equivalent to :undefined . Numbers All integers are Erlang integers (arbitrary precision). Strings are UTF-8 encoded Erlang binaries. Characters are single-char strings. Collections Clojerl uses the same hash computations as Clojure. When possible a native Erlang data structure is used (i.e. map, list, tuple) in the underlying implementation. List uses an Erlang list. Vector uses clj_vector , which is an Erlang implementation of Clojure's persistent vector. Map uses an Erlang map. Sorted Maps use Robert Virding's implementation of red-black trees. Sets use Erlang maps. StructMap will not be implemented since \"most uses of StructMaps would now be better served by records\". ArrayMap's closest relative in Clojerl is TupleMap. Literal Erlang collections can be included in code by using the #erl dispatch reader macro: #erl () Erlang lists #erl [] Erlang tuples #erl {} Erlang maps Datatypes defprotocol and deftype , extend-type , extend-protocol work as in Clojure. Protocols are not reified as in Clojure, there are no runtime protocol objects. Some reflective capabilities ( satisfies? ) work as in Clojure. extend is not implemented. reify is not implemented. Sequences Seqs are the same as in Clojure. Transient Data Structures Transients are currently not implemeted. Transducers Stateful transducers are currently not implemeted. Multimethods and Hierarchies Multimethods works as in Clojure. Hierarchies are not implemented. Metadata Works as in Clojure for all the same data structures, except for fn s. Anonymous functions are compiled into Erlang closures, for which there is no way to bolt arbitrary information. Namespaces Namespaces are compiled into Erlang modules. They are available at runtime for inspection, as in Clojure. Libs Existing Clojure libs will have to conform to the Clojerl subset in order to work in Clojerl. Vars and the Global Environment def , binding and set! work as in Clojure def yields the Var itself as in Clojure. Root bindings can't be modified (e.g. with alter-var-root or with-redefs ). Vars can't have watches or a validator. Atom and Agent implementations are experimental. Refs are not currently implemented. Refs and Transactions Refs and Transactions are not implemented. Agents Agent implementation is experimental. Atoms Atom implementation is experimental. Reducers Reducers are not implemented. Host Interop Member access All types in Clojerl have an implementation module with the same name as the type. \"Member access\" is translated to a function call to the specified function in the type's module where the first argument is the value. Type Hinting There are no primitive types in Erlang so there is no use for int , ints , etc. Type hints are used to resolve the target's type at compile-time and avoid having to figure out at run-time. Calling Clojerl from Erlang Since Clojerl namespaces are Erlang modules, calling a function from the clojure.core module is as simple as: 'clojure.core':inc(1). %%= 2 Ahead-of-time Compilation and Class Generation Each namespace is generally compiled into one Erlang module, except when defrecord , deftype or one of the extend-* functions is used. gen-class , gen-interface , etc. are unnecessary and unimplemented in Clojerl. Other Included Libraries clojure.erlang.io is an attempt to provide the same polymorphic I/O utility functions for Erlang. clojure.erlang.erldocs (Missing) clojure.erlang.shell (Missing) clojure.repl clojure.set clojure.string clojure.test clojure.walk clojure.xml clojure.zip clojure.core.reducers (Missing) clojure.spec (Missing) clojure.pprint","title":"Differences with Clojure"},{"location":"differences-with-clojure/#rationale","text":"Erlang is a great language for building safe, reliable and scalable systems. It provides immutable, persistent data structures out of the box and its concurrency semantics are unequalled by any other language. Clojure is a Lisp and as such comes with all the goodies Lisps provide. Apart from these Clojure also introduces powerful abstractions such as protocols, multimethods and seqs, to name a few. Clojure was built to simplify the development of concurrent programs and some of its concurrency abstractions could be adapted to Erlang. It is fair to say that combining the power of the Erlang VM with the expressiveness of Clojure could provide an interesting, useful result to make the lives of many programmers simpler and make the world a happier place.","title":"Rationale"},{"location":"differences-with-clojure/#state-and-identity","text":"The Erlang VM implements the actor model, which means identity is generally bound to a process which maintains an internal state . This doesn't mean that the Clojure identity model can't be implemented, but since the platform favors the actor model, it will always be more efficient using it than the Clojure model.","title":"State and Identity"},{"location":"differences-with-clojure/#clojurespec","text":"Not implemented (yet).","title":"clojure.spec"},{"location":"differences-with-clojure/#dynamic-development","text":"There is a REPL available just like Clojure's.","title":"Dynamic Development"},{"location":"differences-with-clojure/#functional-programming","text":"Since the Erlang VM already includes native immutable data structures, Clojerl includes most of the same immutable data structures present in Clojure. Some of them are implemented based on other immutable data structures (e.g. sorted sets).","title":"Functional Programming"},{"location":"differences-with-clojure/#lisp","text":"Same as in Clojure.","title":"Lisp"},{"location":"differences-with-clojure/#runtime-polymorphism","text":"Protocols and multimethods are available as in Clojure. Everything is implemented in terms of protocols, there are no interfaces. proxy is not supported.","title":"Runtime Polymorphism"},{"location":"differences-with-clojure/#concurrent-programming","text":"TBD","title":"Concurrent Programming"},{"location":"differences-with-clojure/#hosted-on-the-jvm","text":"Hosted on the Erlang VM.","title":"Hosted on the JVM"},{"location":"differences-with-clojure/#getting-started","text":"Getting started .","title":"Getting Started"},{"location":"differences-with-clojure/#the-reader","text":"Numbers All integer numbers are mapped to Erlang's representation, which are arbitrary precision integers. Numbers with a decimal part are mapped to Erlang's representation of floating point numbers. Ratio and BigDecimal are not supported. Characters are represented as single-character strings. nil is currently mapped to the :undefined keyword. This is because :undefined is generally used in Erlang to specify 'nothing/no-value'. true and false are equivalent to :true and :false respectively. Lists, Vectors, Maps and Sets are the same as in Clojure. There is no support yet for the Map namespace syntax . Macro characters Because there is no character type in Erlang, \\ produces a single-character string.","title":"The Reader"},{"location":"differences-with-clojure/#the-repl-and-main","text":"See Getting started for instructions on the Clojerl REPL. The bin/clojerl and bin/clje scripts can be used the same as bin/clojure and bin/clj .","title":"The REPL and main"},{"location":"differences-with-clojure/#evaluation","text":"Clojerl has the same evaluation rules as Clojure.","title":"Evaluation"},{"location":"differences-with-clojure/#special-forms","text":"The following Clojerl special forms are identical to their Clojure cousins: if , do , let , letfn , quote and loop . fn Compile to an Erlang function and therefore can't have any metadata. recur recur is compiled to an actual recursive call that is only allowed in tail position, since the Erlang VM implements tail call optimization. def When the init expression is a fn , def produces one or more Erlang functions, depending on the arities specified in the fn declaration. When not an fn , the init expression ( which is evaluated at compile-time ) must return a constant literal, otherwise it's a compile-time error. throw There is no error type in Erlang, any value can be thrown. try..catch..finally An exception in Erlang consists of three things: the class of the exception ( throw , error or exit ), the exit reason and the stack-trace. There is no specific type for exceptions. The spec for the catch clause is (catch error-type error & body) , where error-type is one of the keywords :throw , :error , :exit or _ . The last one will catch all the error types. var Vars are not reified as in Clojure, they are more similar to what ClojureScript does, which returns compile time information about the var, and during runtime the information available is static (i.e. can't be modified without recompiling). Vars can't have watches or a validator. It's not possible to change the root binding of a Var. monitor-enter , monitor-exit , and locking are not supported.","title":"Special Forms"},{"location":"differences-with-clojure/#macros","text":"Macros in Clojerl work the same as in Clojure.","title":"Macros"},{"location":"differences-with-clojure/#other-useful-functions-and-macros","text":"Regex support is the one provided by the re Erlang module.","title":"Other Useful Functions and Macros"},{"location":"differences-with-clojure/#data-structures","text":"nil 's type is clojerl.Nil . It is equivalent to :undefined . Numbers All integers are Erlang integers (arbitrary precision). Strings are UTF-8 encoded Erlang binaries. Characters are single-char strings. Collections Clojerl uses the same hash computations as Clojure. When possible a native Erlang data structure is used (i.e. map, list, tuple) in the underlying implementation. List uses an Erlang list. Vector uses clj_vector , which is an Erlang implementation of Clojure's persistent vector. Map uses an Erlang map. Sorted Maps use Robert Virding's implementation of red-black trees. Sets use Erlang maps. StructMap will not be implemented since \"most uses of StructMaps would now be better served by records\". ArrayMap's closest relative in Clojerl is TupleMap. Literal Erlang collections can be included in code by using the #erl dispatch reader macro: #erl () Erlang lists #erl [] Erlang tuples #erl {} Erlang maps","title":"Data Structures"},{"location":"differences-with-clojure/#datatypes","text":"defprotocol and deftype , extend-type , extend-protocol work as in Clojure. Protocols are not reified as in Clojure, there are no runtime protocol objects. Some reflective capabilities ( satisfies? ) work as in Clojure. extend is not implemented. reify is not implemented.","title":"Datatypes"},{"location":"differences-with-clojure/#sequences","text":"Seqs are the same as in Clojure.","title":"Sequences"},{"location":"differences-with-clojure/#transient-data-structures","text":"Transients are currently not implemeted.","title":"Transient Data Structures"},{"location":"differences-with-clojure/#transducers","text":"Stateful transducers are currently not implemeted.","title":"Transducers"},{"location":"differences-with-clojure/#multimethods-and-hierarchies","text":"Multimethods works as in Clojure. Hierarchies are not implemented.","title":"Multimethods and Hierarchies"},{"location":"differences-with-clojure/#metadata","text":"Works as in Clojure for all the same data structures, except for fn s. Anonymous functions are compiled into Erlang closures, for which there is no way to bolt arbitrary information.","title":"Metadata"},{"location":"differences-with-clojure/#namespaces","text":"Namespaces are compiled into Erlang modules. They are available at runtime for inspection, as in Clojure.","title":"Namespaces"},{"location":"differences-with-clojure/#libs","text":"Existing Clojure libs will have to conform to the Clojerl subset in order to work in Clojerl.","title":"Libs"},{"location":"differences-with-clojure/#vars-and-the-global-environment","text":"def , binding and set! work as in Clojure def yields the Var itself as in Clojure. Root bindings can't be modified (e.g. with alter-var-root or with-redefs ). Vars can't have watches or a validator. Atom and Agent implementations are experimental. Refs are not currently implemented.","title":"Vars and the Global Environment"},{"location":"differences-with-clojure/#refs-and-transactions","text":"Refs and Transactions are not implemented.","title":"Refs and Transactions"},{"location":"differences-with-clojure/#agents","text":"Agent implementation is experimental.","title":"Agents"},{"location":"differences-with-clojure/#atoms","text":"Atom implementation is experimental.","title":"Atoms"},{"location":"differences-with-clojure/#reducers","text":"Reducers are not implemented.","title":"Reducers"},{"location":"differences-with-clojure/#host-interop","text":"Member access All types in Clojerl have an implementation module with the same name as the type. \"Member access\" is translated to a function call to the specified function in the type's module where the first argument is the value. Type Hinting There are no primitive types in Erlang so there is no use for int , ints , etc. Type hints are used to resolve the target's type at compile-time and avoid having to figure out at run-time. Calling Clojerl from Erlang Since Clojerl namespaces are Erlang modules, calling a function from the clojure.core module is as simple as: 'clojure.core':inc(1). %%= 2","title":"Host Interop"},{"location":"differences-with-clojure/#ahead-of-time-compilation-and-class-generation","text":"Each namespace is generally compiled into one Erlang module, except when defrecord , deftype or one of the extend-* functions is used. gen-class , gen-interface , etc. are unnecessary and unimplemented in Clojerl.","title":"Ahead-of-time Compilation and Class Generation"},{"location":"differences-with-clojure/#other-included-libraries","text":"clojure.erlang.io is an attempt to provide the same polymorphic I/O utility functions for Erlang. clojure.erlang.erldocs (Missing) clojure.erlang.shell (Missing) clojure.repl clojure.set clojure.string clojure.test clojure.walk clojure.xml clojure.zip clojure.core.reducers (Missing) clojure.spec (Missing) clojure.pprint","title":"Other Included Libraries"},{"location":"getting-started/","text":"Getting Started Build clojerl from source (requires Erlang/OTP 18+ and rebar3 ): git clone https://github.com/jfacorro/clojerl cd clojerl make Running make repl will start the REPL and show its prompt: Clojure 0.0.0-974.592ad8a clje.user=> Or alternatively you can use the bin/clojerl command for the same purpose: bin/clojerl","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Build clojerl from source (requires Erlang/OTP 18+ and rebar3 ): git clone https://github.com/jfacorro/clojerl cd clojerl make Running make repl will start the REPL and show its prompt: Clojure 0.0.0-974.592ad8a clje.user=> Or alternatively you can use the bin/clojerl command for the same purpose: bin/clojerl","title":"Getting Started"}]}