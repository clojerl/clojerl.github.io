{
    "docs": [
        {
            "location": "/", 
            "text": "Clojure for the Erlang VM\n\n\nErlang is a great language for building safe, reliable and scalable systems. It\nprovides immutable, persistent data structures out of the box and its\nconcurrency semantics are unequalled by any other language.\n\n\nClojure is a Lisp and as such comes with all the goodies Lisps provide. Apart\nfrom these Clojure also introduces powerful abstractions such as protocols,\nmulti-methods and seqs, to name a few.\n\n\nClojure was originally built to simplify the development of concurrent programs\nin the JVM. Some of its concurrency abstractions could be adapted to Erlang, but\nthis is not the main goal of this project. Its main goal is to combine the power\nof the Erlang VM with the expressiveness of Clojure to provide an interesting,\nuseful result that might make the lives of many programmers simpler and make the\nworld a happier place.\n\n\nGetting Started\n\n\nBuild \nclojerl\n form source (requires \nErlang/OTP 18+\n and \nrebar3\n):\n\n\ngit clone https://github.com/jfacorro/clojerl\ncd clojerl\nmake\n\n\n\nRunning \nmake repl\n will start the REPL and show its prompt:\n\n\nClojure 0.0.0-974.592ad8a\nclje.user=\n\n\n\n\nOr alternatively you can use the \nbin/clojerl\n command for the same purpose:\n\n\nbin/clojerl --clojure.main -r", 
            "title": "Clojerl"
        }, 
        {
            "location": "/#clojure-for-the-erlang-vm", 
            "text": "Erlang is a great language for building safe, reliable and scalable systems. It\nprovides immutable, persistent data structures out of the box and its\nconcurrency semantics are unequalled by any other language.  Clojure is a Lisp and as such comes with all the goodies Lisps provide. Apart\nfrom these Clojure also introduces powerful abstractions such as protocols,\nmulti-methods and seqs, to name a few.  Clojure was originally built to simplify the development of concurrent programs\nin the JVM. Some of its concurrency abstractions could be adapted to Erlang, but\nthis is not the main goal of this project. Its main goal is to combine the power\nof the Erlang VM with the expressiveness of Clojure to provide an interesting,\nuseful result that might make the lives of many programmers simpler and make the\nworld a happier place.", 
            "title": "Clojure for the Erlang VM"
        }, 
        {
            "location": "/#getting-started", 
            "text": "Build  clojerl  form source (requires  Erlang/OTP 18+  and  rebar3 ):  git clone https://github.com/jfacorro/clojerl\ncd clojerl\nmake  Running  make repl  will start the REPL and show its prompt:  Clojure 0.0.0-974.592ad8a\nclje.user=   Or alternatively you can use the  bin/clojerl  command for the same purpose:  bin/clojerl --clojure.main -r", 
            "title": "Getting Started"
        }, 
        {
            "location": "/available-features/", 
            "text": "We provide here a list of the features that are already implemented and\navailable, the ones that are still missing and those that can't or won't be\nsupported.\n\n\nFor a detailed list on the differences between Clojerl and Clojure please check\n\nhere\n.\n\n\nImplemented\n\n\n\n\nSpecial Forms\n\n\nClojure: \ndef\n, \ndo\n, \nfn*\n, \nif\n, \nquote\n, \nlet*\n, \nletfn*\n, \nloop*\n,\n  \nrecur\n, \ncase*\n, \nthrow\n, \ntry\n, \nvar\n, \nimport*\n, \nnew\n, \ndeftype*\n,\n  \ndefprotocol*\n, \nextend-type*\n, \n.\n\n\nErlang: \nreceive*\n, \nerl-binary*\n, \nerl-list*\n, \nerl-alias*\n,\n  \nerl-on-load*\n\n\n\n\n\n\nMulti-method\n\n\nData Structures\n\n\nClojure\n\n\nChunkedCons\n\n\nCons\n\n\nLazySeq\n\n\nList\n\n\nMap\n\n\nRange\n\n\nSet\n\n\nSortedSet\n\n\nSortedMap\n\n\nVector\n\n\nVector.ChunkedSeq\n\n\n\n\n\n\nErlang\n\n\nMap\n\n\nList\n\n\nTuple\n\n\n\n\n\n\n\n\n\n\nConcurrency\n\n\nAtom (naive implementation)\n\n\n\n\n\n\nClojure Libraries\n\n\nclojure.core\n\n\nclojure.core.server\n\n\nclojure.data\n\n\nclojure.erlang.io\n\n\nclojure.instant\n\n\nclojure.repl\n\n\nclojure.main\n\n\nclojure.pprint\n\n\nclojure.set\n\n\nclojure.stacktrace\n\n\nclojure.string\n\n\nclojure.template\n\n\nclojure.test\n\n\nclojure.uuid\n\n\nclojure.walk\n\n\nclojure.xml\n\n\nclojure.zip\n\n\n\n\n\n\n\n\nMissing\n\n\n\n\nMulti-method\n\n\nHierarchies\n\n\n\n\n\n\nConcurrency\n\n\nRef\n\n\nAgent\n\n\nDelay\n\n\nFuture\n\n\nPromise\n\n\n\n\n\n\nData Structures\n\n\nStructMaps\n\n\nMap namespace syntax\n\n\n\n\n\n\nTransducers\n\n\nClojure Libraries\n\n\nclojure.edn\n\n\nclojure.erlang.erldocs\n\n\nclojure.erlang.shell\n\n\nclojure.core.reducers\n\n\nclojure.spec\n\n\n\n\n\n\n\n\nUnsupported\n\n\n\n\nConcurrency\n\n\nVolatile\n\n\n\n\n\n\nData Structures\n\n\nTransient collections\n\n\n\n\n\n\nMath\n\n\nunchecked", 
            "title": "Available Features"
        }, 
        {
            "location": "/available-features/#implemented", 
            "text": "Special Forms  Clojure:  def ,  do ,  fn* ,  if ,  quote ,  let* ,  letfn* ,  loop* ,\n   recur ,  case* ,  throw ,  try ,  var ,  import* ,  new ,  deftype* ,\n   defprotocol* ,  extend-type* ,  .  Erlang:  receive* ,  erl-binary* ,  erl-list* ,  erl-alias* ,\n   erl-on-load*    Multi-method  Data Structures  Clojure  ChunkedCons  Cons  LazySeq  List  Map  Range  Set  SortedSet  SortedMap  Vector  Vector.ChunkedSeq    Erlang  Map  List  Tuple      Concurrency  Atom (naive implementation)    Clojure Libraries  clojure.core  clojure.core.server  clojure.data  clojure.erlang.io  clojure.instant  clojure.repl  clojure.main  clojure.pprint  clojure.set  clojure.stacktrace  clojure.string  clojure.template  clojure.test  clojure.uuid  clojure.walk  clojure.xml  clojure.zip", 
            "title": "Implemented"
        }, 
        {
            "location": "/available-features/#missing", 
            "text": "Multi-method  Hierarchies    Concurrency  Ref  Agent  Delay  Future  Promise    Data Structures  StructMaps  Map namespace syntax    Transducers  Clojure Libraries  clojure.edn  clojure.erlang.erldocs  clojure.erlang.shell  clojure.core.reducers  clojure.spec", 
            "title": "Missing"
        }, 
        {
            "location": "/available-features/#unsupported", 
            "text": "Concurrency  Volatile    Data Structures  Transient collections    Math  unchecked", 
            "title": "Unsupported"
        }, 
        {
            "location": "/differences-with-clojure/", 
            "text": "(This document was built using the\n\none from ClojureScript\n\nas a guide).\n\n\nRationale\n\n\nErlang is a great language for building safe, reliable and scalable\nsystems. It provides immutable, persistent data structures out of the\nbox and its concurrency semantics are unequalled by any other\nlanguage.\n\n\nClojure is a Lisp and as such comes with all the goodies Lisps\nprovide. Apart from these Clojure also introduces powerful\nabstractions such as protocols, multimethods and seqs, to name a few.\n\n\nClojure was built to simplify the development of concurrent programs\nand some of its concurrency abstractions could be adapted to Erlang.\nIt is fair to say that combining the power of the Erlang VM with the\nexpressiveness of Clojure could provide an interesting, useful result\nto make the lives of many programmers simpler and make the world a\nhappier place.\n\n\nState and Identity\n\n\nThe Erlang VM implements the actor model, which means \nidentity\n is\ngenerally bound to a process which maintains an internal \nstate\n. This\ndoesn't mean that the Clojure identity model can't be implemented, but\nsince the platform favors the actor model, it will always be more\nefficient using it than the Clojure model.\n\n\nclojure.spec\n\n\nNot implemented (yet).\n\n\nDynamic Development\n\n\nThere is a REPL available just like Clojure's.\n\n\nFunctional Programming\n\n\nSince the Erlang VM already includes native immutable data structures,\nClojerl includes most of the immutable data structures as Clojure.\nSome of them are implemented based on other immutable data structures\n(e.g. sorted sets).\n\n\nLisp\n\n\nSame as in Clojure.\n\n\nRuntime Polymorphism\n\n\nProtocols and multimethods are available as in Clojure. Everything is\nimplemented in terms of protocols, there are no interfaces. \nproxy\n is\nnot supported.\n\n\nConcurrent Programming\n\n\nTBD\n\n\nHosted on the JVM\n\n\nHosted on the Erlang VM.\n\n\nGetting Started\n\n\nGetting started\n.\n\n\nThe Reader\n\n\n\n\nNumbers\n\n\nAll integer numbers are mapped to Erlang's representation, which\n    are arbitrary precision integers.\n\n\nNumbers with a decimal part are mapped to Erlang's representation\n    of floating point numbers.\n\n\nRatio and BigDecimal are not supported.\n\n\nCharacters are represented as single-character strings.\n\n\nnil\n is currently mapped to the \n:undefined\n keyword. This is\n    because \n:undefined\n is generally used in Erlang to specify\n    'nothing/no-value'.\n\n\ntrue\n and \nfalse\n are equivalent to \n:true\n and \n:false\n\n  respectively.\n\n\nLists, Vectors, Maps and Sets are the same as in Clojure. There is\n  no support yet for the 'Map namespace syntax'.\n\n\nMacro characters\n\n\nBecause there is no character type in Erlang, \n\\\n produces a\n    single-character string.\n\n\n\n\nThe REPL and main\n\n\n\n\nThe \nbin/clojure.main\n script shows how it is possible to use\n  the features provided by the \nclojure.main\n namespace.\n\n\nThe socket-based REPL is currently not available.\n\n\n\n\nEvaluation\n\n\n\n\nClojerl has the same evaluation rules as Clojure.\n\n\n\n\nSpecial Forms\n\n\nThe following ClojureScript special forms are identical to their\nClojure cousins: \nif\n, \ndo\n, \nlet\n, \nletfn\n, \nquote\n and \nloop\n.\n\n\n\n\nfn\n\n\nCompile to an Erlang function and therefore can't have any\n    metadata.\n\n\nrecur\n\n\nrecur\n is compiled to an actual recursive call that is only\n    allowed in tail position, since the Erlang VM implements tail call\n    optimization.\n\n\ndef\n\n\nWhen the init expression is a \nfn\n, \ndef\n produces one or more\n    Erlang functions, depending on the arities specified in the \nfn\n\n    declaration.\n\n\nWhen not an \nfn\n, the init expression (\nwhich is evaluated at\n    compile-time\n) \nmust\n return a constant literal, otherwise it's a\n    compile-time error.\n\n\nthrow\n\n\nThere is no error type in Erlang, any value can be thrown.\n\n\ntry..catch..finally\n\n\nAn exception in Erlang consists of three things: the class of the\n    exception (\nthrow\n, \nerror\n or \nexit\n), the exit reason and the\n    stack-trace. There is no specific type for exceptions.\n\n\nThe spec for the \ncatch\n clause is \n(catch error-type error \n\n    body)\n, where \nerror-type\n is one of the keywords \n:throw\n,\n    \n:error\n, \n:exit\n or \n_\n. The last one will catch all the error\n    types.\n\n\nvar\n\n\nVars are not reified as in Clojure, they are more similar to what\n    ClojureScript does, which returns compile time information about\n    the var.\n\n\nmonitor-enter\n, \nmonitor-exit\n, and \nlocking\n are not implemented.\n\n\n\n\nMacros\n\n\nMacro in Clojerl work the same as in Clojure.\n\n\nOther Useful Functions and Macros\n\n\n\n\nRegex support is the one provided by the \nre\n Erlang module.\n\n\n\n\nData Structures\n\n\n\n\nnil\n's type is \nclojerl.Nil\n. It is equivalent to \n:undefined\n.\n\n\nNumbers\n\n\nAll integers are Erlang integers (arbitrary precision).\n\n\nStrings are UTF-8 encoded Erlang binaries.\n\n\nCharacters are single-char strings.\n\n\nCollections\n\n\nClojerl uses the same hash computations as Clojure.\n\n\nWhen possible the native Erlang data structure is used (i.e. map,\n    list, tuple).\n\n\nList uses an Erlang list.\n\n\nVector uses the \narray\n Erlang module.\n\n\nMap uses an Erlang map.\n\n\nSorted Maps use Robert Virding's implementation of red-black\n  trees.\n\n\nSets use Erlang maps.\n\n\nStructMap and ArrayMap are currently not implemented.\n\n\n\n\n\n\n\n\nDatatypes\n\n\n\n\ndefprotocol\n and \ndeftype\n, \nextend-type\n, \nextend-protocol\n work as in Clojure.\n\n\nProtocols are not reified as in Clojure, there are no runtime protocol objects.\n\n\nSome reflective capabilities (\nsatisfies?\n) work as in Clojure.\n\n\nextend\n is not implemented.\n\n\nreify\n is not implemented.\n\n\n\n\nSequences\n\n\n\n\nSeqs are the same as in Clojure.\n\n\n\n\nTransient Data Structures\n\n\nTransients are currently not implemeted.\n\n\nTransducers\n\n\nTransducers are currently not implemeted.\n\n\nMultimethods and Hierarchies\n\n\n\n\nMultimethods works as in Clojure.\n\n\nHierarchies are not implemented.\n\n\n\n\nMetadata\n\n\nWorks as in Clojure for all the same data structures, except for\n\nfn\ns.\n\n\nAnonymous functions are compiled into Erlang closures, for which there\nis no way to bolt arbitrary information.\n\n\nNamespaces\n\n\nNamespaces are compiled into Erlang modules. They are available at\nruntime for inspection, as in Clojure.\n\n\nLibs\n\n\nExisting Clojure libs will have to conform to the Clojerl subset\nin order to work in Clojerl.\n\n\nVars and the Global Environment\n\n\n\n\nVars (i.e. \ndef\n, \nbinding\n and \nset!\n) work as in Clojure.\n\n\nAtoms, Refs and Agents are not currently implemented.\n\n\n\n\nRefs and Transactions\n\n\nRefs and Transactions are not implemented.\n\n\nAgents\n\n\nAgents are not implemented.\n\n\nAtoms\n\n\nAtoms are not implemented.\n\n\nReducers\n\n\nReducers are not implemented.\n\n\nHost Interop\n\n\n\n\nMember access\n\n\nAll types in Clojerl have an implementation module with the same\n    name as the type. \"Member access\" is translated to a function call\n    to the specified function in the type's module where the first\n    argument is the value.\n\n\nType Hinting\n\n\nThere are no primitive types in Erlang so there is no use for\n  \nint\n, \nints\n, etc.\n\n\nType hints are used to resolve the target's type at compile-time\n    and avoid having to figure out at run-time.\n\n\nSimple XML support is currently not implemented.\n\n\nCalling Clojerl from Erlang\n\n\n\n\nSince Clojerl namespaces are Erlang modules, calling a function\n    from the \nclojure.core\n module is as simple as:\n\n\n'clojure.core':inc(1).\n%%= 2\n\n\n\n\n\n\nAhead-of-time Compilation and Class Generation\n\n\n\n\nEach namespace is generally compiled into one Erlang module, except\n  when \ndefrecord\n, \ndeftype\n or one of the \nextend-*\n functions is\n  used.\n\n\ngen-class\n, \ngen-interface\n, etc. are unnecessary and unimplemented in\n  Clojerl.\n\n\n\n\nOther Included Libraries\n\n\n\n\nclojure.erlang.io\n is an attempt to provide the same polymorphic\n  I/O utility functions for Erlang.\n\n\nclojure.erlang.erldocs\n (Missing)\n\n\nclojure.erlang.shell\n (Missing)\n\n\nclojure.repl\n\n\nclojure.set\n\n\nclojure.string\n\n\nclojure.test\n\n\nclojure.walk\n\n\nclojure.xml\n\n\nclojure.zip\n\n\nclojure.core.reducers\n (Missing)\n\n\nclojure.spec\n (Missing)\n\n\nclojure.pprint", 
            "title": "Differences with Clojure"
        }, 
        {
            "location": "/differences-with-clojure/#rationale", 
            "text": "Erlang is a great language for building safe, reliable and scalable\nsystems. It provides immutable, persistent data structures out of the\nbox and its concurrency semantics are unequalled by any other\nlanguage.  Clojure is a Lisp and as such comes with all the goodies Lisps\nprovide. Apart from these Clojure also introduces powerful\nabstractions such as protocols, multimethods and seqs, to name a few.  Clojure was built to simplify the development of concurrent programs\nand some of its concurrency abstractions could be adapted to Erlang.\nIt is fair to say that combining the power of the Erlang VM with the\nexpressiveness of Clojure could provide an interesting, useful result\nto make the lives of many programmers simpler and make the world a\nhappier place.", 
            "title": "Rationale"
        }, 
        {
            "location": "/differences-with-clojure/#state-and-identity", 
            "text": "The Erlang VM implements the actor model, which means  identity  is\ngenerally bound to a process which maintains an internal  state . This\ndoesn't mean that the Clojure identity model can't be implemented, but\nsince the platform favors the actor model, it will always be more\nefficient using it than the Clojure model.", 
            "title": "State and Identity"
        }, 
        {
            "location": "/differences-with-clojure/#clojurespec", 
            "text": "Not implemented (yet).", 
            "title": "clojure.spec"
        }, 
        {
            "location": "/differences-with-clojure/#dynamic-development", 
            "text": "There is a REPL available just like Clojure's.", 
            "title": "Dynamic Development"
        }, 
        {
            "location": "/differences-with-clojure/#functional-programming", 
            "text": "Since the Erlang VM already includes native immutable data structures,\nClojerl includes most of the immutable data structures as Clojure.\nSome of them are implemented based on other immutable data structures\n(e.g. sorted sets).", 
            "title": "Functional Programming"
        }, 
        {
            "location": "/differences-with-clojure/#lisp", 
            "text": "Same as in Clojure.", 
            "title": "Lisp"
        }, 
        {
            "location": "/differences-with-clojure/#runtime-polymorphism", 
            "text": "Protocols and multimethods are available as in Clojure. Everything is\nimplemented in terms of protocols, there are no interfaces.  proxy  is\nnot supported.", 
            "title": "Runtime Polymorphism"
        }, 
        {
            "location": "/differences-with-clojure/#concurrent-programming", 
            "text": "TBD", 
            "title": "Concurrent Programming"
        }, 
        {
            "location": "/differences-with-clojure/#hosted-on-the-jvm", 
            "text": "Hosted on the Erlang VM.", 
            "title": "Hosted on the JVM"
        }, 
        {
            "location": "/differences-with-clojure/#getting-started", 
            "text": "Getting started .", 
            "title": "Getting Started"
        }, 
        {
            "location": "/differences-with-clojure/#the-reader", 
            "text": "Numbers  All integer numbers are mapped to Erlang's representation, which\n    are arbitrary precision integers.  Numbers with a decimal part are mapped to Erlang's representation\n    of floating point numbers.  Ratio and BigDecimal are not supported.  Characters are represented as single-character strings.  nil  is currently mapped to the  :undefined  keyword. This is\n    because  :undefined  is generally used in Erlang to specify\n    'nothing/no-value'.  true  and  false  are equivalent to  :true  and  :false \n  respectively.  Lists, Vectors, Maps and Sets are the same as in Clojure. There is\n  no support yet for the 'Map namespace syntax'.  Macro characters  Because there is no character type in Erlang,  \\  produces a\n    single-character string.", 
            "title": "The Reader"
        }, 
        {
            "location": "/differences-with-clojure/#the-repl-and-main", 
            "text": "The  bin/clojure.main  script shows how it is possible to use\n  the features provided by the  clojure.main  namespace.  The socket-based REPL is currently not available.", 
            "title": "The REPL and main"
        }, 
        {
            "location": "/differences-with-clojure/#evaluation", 
            "text": "Clojerl has the same evaluation rules as Clojure.", 
            "title": "Evaluation"
        }, 
        {
            "location": "/differences-with-clojure/#special-forms", 
            "text": "The following ClojureScript special forms are identical to their\nClojure cousins:  if ,  do ,  let ,  letfn ,  quote  and  loop .   fn  Compile to an Erlang function and therefore can't have any\n    metadata.  recur  recur  is compiled to an actual recursive call that is only\n    allowed in tail position, since the Erlang VM implements tail call\n    optimization.  def  When the init expression is a  fn ,  def  produces one or more\n    Erlang functions, depending on the arities specified in the  fn \n    declaration.  When not an  fn , the init expression ( which is evaluated at\n    compile-time )  must  return a constant literal, otherwise it's a\n    compile-time error.  throw  There is no error type in Erlang, any value can be thrown.  try..catch..finally  An exception in Erlang consists of three things: the class of the\n    exception ( throw ,  error  or  exit ), the exit reason and the\n    stack-trace. There is no specific type for exceptions.  The spec for the  catch  clause is  (catch error-type error  \n    body) , where  error-type  is one of the keywords  :throw ,\n     :error ,  :exit  or  _ . The last one will catch all the error\n    types.  var  Vars are not reified as in Clojure, they are more similar to what\n    ClojureScript does, which returns compile time information about\n    the var.  monitor-enter ,  monitor-exit , and  locking  are not implemented.", 
            "title": "Special Forms"
        }, 
        {
            "location": "/differences-with-clojure/#macros", 
            "text": "Macro in Clojerl work the same as in Clojure.", 
            "title": "Macros"
        }, 
        {
            "location": "/differences-with-clojure/#other-useful-functions-and-macros", 
            "text": "Regex support is the one provided by the  re  Erlang module.", 
            "title": "Other Useful Functions and Macros"
        }, 
        {
            "location": "/differences-with-clojure/#data-structures", 
            "text": "nil 's type is  clojerl.Nil . It is equivalent to  :undefined .  Numbers  All integers are Erlang integers (arbitrary precision).  Strings are UTF-8 encoded Erlang binaries.  Characters are single-char strings.  Collections  Clojerl uses the same hash computations as Clojure.  When possible the native Erlang data structure is used (i.e. map,\n    list, tuple).  List uses an Erlang list.  Vector uses the  array  Erlang module.  Map uses an Erlang map.  Sorted Maps use Robert Virding's implementation of red-black\n  trees.  Sets use Erlang maps.  StructMap and ArrayMap are currently not implemented.", 
            "title": "Data Structures"
        }, 
        {
            "location": "/differences-with-clojure/#datatypes", 
            "text": "defprotocol  and  deftype ,  extend-type ,  extend-protocol  work as in Clojure.  Protocols are not reified as in Clojure, there are no runtime protocol objects.  Some reflective capabilities ( satisfies? ) work as in Clojure.  extend  is not implemented.  reify  is not implemented.", 
            "title": "Datatypes"
        }, 
        {
            "location": "/differences-with-clojure/#sequences", 
            "text": "Seqs are the same as in Clojure.", 
            "title": "Sequences"
        }, 
        {
            "location": "/differences-with-clojure/#transient-data-structures", 
            "text": "Transients are currently not implemeted.", 
            "title": "Transient Data Structures"
        }, 
        {
            "location": "/differences-with-clojure/#transducers", 
            "text": "Transducers are currently not implemeted.", 
            "title": "Transducers"
        }, 
        {
            "location": "/differences-with-clojure/#multimethods-and-hierarchies", 
            "text": "Multimethods works as in Clojure.  Hierarchies are not implemented.", 
            "title": "Multimethods and Hierarchies"
        }, 
        {
            "location": "/differences-with-clojure/#metadata", 
            "text": "Works as in Clojure for all the same data structures, except for fn s.  Anonymous functions are compiled into Erlang closures, for which there\nis no way to bolt arbitrary information.", 
            "title": "Metadata"
        }, 
        {
            "location": "/differences-with-clojure/#namespaces", 
            "text": "Namespaces are compiled into Erlang modules. They are available at\nruntime for inspection, as in Clojure.", 
            "title": "Namespaces"
        }, 
        {
            "location": "/differences-with-clojure/#libs", 
            "text": "Existing Clojure libs will have to conform to the Clojerl subset\nin order to work in Clojerl.", 
            "title": "Libs"
        }, 
        {
            "location": "/differences-with-clojure/#vars-and-the-global-environment", 
            "text": "Vars (i.e.  def ,  binding  and  set! ) work as in Clojure.  Atoms, Refs and Agents are not currently implemented.", 
            "title": "Vars and the Global Environment"
        }, 
        {
            "location": "/differences-with-clojure/#refs-and-transactions", 
            "text": "Refs and Transactions are not implemented.", 
            "title": "Refs and Transactions"
        }, 
        {
            "location": "/differences-with-clojure/#agents", 
            "text": "Agents are not implemented.", 
            "title": "Agents"
        }, 
        {
            "location": "/differences-with-clojure/#atoms", 
            "text": "Atoms are not implemented.", 
            "title": "Atoms"
        }, 
        {
            "location": "/differences-with-clojure/#reducers", 
            "text": "Reducers are not implemented.", 
            "title": "Reducers"
        }, 
        {
            "location": "/differences-with-clojure/#host-interop", 
            "text": "Member access  All types in Clojerl have an implementation module with the same\n    name as the type. \"Member access\" is translated to a function call\n    to the specified function in the type's module where the first\n    argument is the value.  Type Hinting  There are no primitive types in Erlang so there is no use for\n   int ,  ints , etc.  Type hints are used to resolve the target's type at compile-time\n    and avoid having to figure out at run-time.  Simple XML support is currently not implemented.  Calling Clojerl from Erlang   Since Clojerl namespaces are Erlang modules, calling a function\n    from the  clojure.core  module is as simple as:  'clojure.core':inc(1).\n%%= 2", 
            "title": "Host Interop"
        }, 
        {
            "location": "/differences-with-clojure/#ahead-of-time-compilation-and-class-generation", 
            "text": "Each namespace is generally compiled into one Erlang module, except\n  when  defrecord ,  deftype  or one of the  extend-*  functions is\n  used.  gen-class ,  gen-interface , etc. are unnecessary and unimplemented in\n  Clojerl.", 
            "title": "Ahead-of-time Compilation and Class Generation"
        }, 
        {
            "location": "/differences-with-clojure/#other-included-libraries", 
            "text": "clojure.erlang.io  is an attempt to provide the same polymorphic\n  I/O utility functions for Erlang.  clojure.erlang.erldocs  (Missing)  clojure.erlang.shell  (Missing)  clojure.repl  clojure.set  clojure.string  clojure.test  clojure.walk  clojure.xml  clojure.zip  clojure.core.reducers  (Missing)  clojure.spec  (Missing)  clojure.pprint", 
            "title": "Other Included Libraries"
        }
    ]
}